(function(exports) {
	var doc = exports.document || document,
		vir = [],
		mains = [],
		convOrders = [],
		arraySlice = ARRSLICE = Array.prototype.slice,
		orders = [],
		hookModel = [];

	function blank() {};

	function msg() {};

	function trim(options) {
		return options.replace(/(\s*)/g, '')
	};

	function hookName(fn, option) {
		try {
			if (fn) {
				fn.bind.apply(fn, arguments)
			}
		} catch (err) {
			exports.warn(err)
		}
	};
	hookName.prototype.init = function(option) {
		this.eventType = 'hook';
		this.module = option;
		this.recievHookModel = null || '?';
		this.self = hookName
	};
	hookName.prototype.model = function(options) {
		var self = hookName,
			that = this,
			model = options.module,
			value = options.val,
			parseOBJ = this.parseObject(model);
		this.init(model);

		function autoMatch() {
			var returnReceivesMethodValue, getBindClassValue = [],
				savePrototypeObject = [],
				assignPrototypeChain = {},
				bindObjectValue = {},
				tStr = trim(msg.toString()),
				massage = tStr.substring(8, 11),
				children = null,
				i = 0,
				g = 0,
				args;
			if (!parseOBJ) return false;
			blank.prototype = parseOBJ.prototype;
			self.prototype = new blank;
			children = new self(parseOBJ, model);
			self.prototype.constructor = children;
			var getPrototypeChain = self.prototype.constructor;
			for (var prop in getPrototypeChain) {
				if (prop !== 'constructor') {
					assignPrototypeChain[prop] = getPrototypeChain[prop];
					savePrototypeObject.push.apply(savePrototypeObject, [assignPrototypeChain[prop]])
				}
			}
			args = ARRSLICE.call(arguments);
			if (args.length > 0) {
				receivesNextMethodPatten = that.preparedListenMethods(args)
			}
			for (var j = 0; j < receivesNextMethodPatten.length; j++) {
				var returnReceivesMethodValue = [value].reduce(receivesNextMethodPatten[j], value);
				bindObjectValue[j] = returnReceivesMethodValue
			}
			var finallyBindDataInPrototypeChain, defineBind = [],
				valArr = [];
			while (i < savePrototypeObject.length) {
				finallyBindDataInPrototypeChain = savePrototypeObject[i].bind.call(savePrototypeObject[i], bindObjectValue[i]);
				i++
			}
			while (g < receivesNextMethodPatten.length) {
				exports[massage + (g + 1)] = bindObjectValue[g];
				g++
			}
			if (exports.api) {
				exports.api = function(selectionCall) {
					return selectionCall
				}
			}
			return assignPrototypeChain
		};
		return {
			self: self,
			then: autoMatch
		}
	};
	hookName.prototype.preparedListenMethods = function() {
		var preparedArray = [],
			args, getArgs;
		for (var k = 0, args = arguments[0]; k < args.length; k++) {
			getArgs = hookName.bind.call(args[k], args[k]);
			preparedArray.push(getArgs)
		}
		return preparedArray
	};
	hookName.prototype.parseObject = function(param) {
		if (isStr(param)) {
			param = eval(param);
			if (isFun(param)) {
				return param
			} else {
				return false
			}
		}
	};

	function REO(element, options) {
		this.options = new order(element, options) || {};
		return this.options
	};
	var order = function(element, options) {
			this._element = element;
			this._content = options;
			this.acceptCallInherit = {
				acceptinfo: null,
				initailizationStatus: {
					writable: false,
					readable: true,
					text: 'writer non supported!' || null,
					enable: true,
					base: ''
				},
				reactStatus: {
					flowing: {
						readable: false,
						enable: false,
						storage: null,
						size: ''
					},
				},
				groups: []
			};
			this.thenCallInherit = {
				storage: [],
				station: [],
				chainStorage: [],
				chainStorageApi: [],
				backUpremoveStorage: []
			};
			this.other = {
				getContainers: null,
				defaultOrders: [],
				virtualVal: [],
				dynamicParameter: [],
				useToExtend: {}
			};
			this.userModel = {};
			mains.push(this)
		};
	order.prototype = {
		set: function() {
			var args = arguments[0];
			for (var prop in args) {
				if (/module|val/i.test(prop)) {
					this.other.useToExtend[prop] = args[prop];
					continue
				} else {
					return '?'
				}
			}
		},
		chain: function(options) {
			var options = options ? options : undefined;
			if (isObj(options)) {
				var getOutside = extend(this.acceptCallInherit.initailizationStatus, options);
				if (this.acceptCallInherit.initailizationStatus.readable && this.acceptCallInherit.initailizationStatus.enable && !this.acceptCallInherit.initailizationStatus.writable && !getOutside.writable) {
					this.set(options);
					var firstInherits = this['acceptCallInherit'];
					this.rebuild();
					if (isObj(firstInherits.initailizationStatus)) {
						var getStatus = firstInherits.initailizationStatus;
						firstInherits.acceptinfo = getStatus.val || getStatus['text']
					}
					this.recieving(firstInherits.acceptinfo);
					delete getStatus;
					delete firstInherits;
					orders.push(this)
				} else {
					this.debug()
				}
			} else {
				this.debug()
			}
			return this
		},
		rebuild: function() {
			return this.group(function(previousScope, attr) {
				var that = previousScope,
					getGroups = attr.groups;
				if (getGroups instanceof Array) {
					getGroups.push(extend(attr.initailizationStatus, that.other.useToExtend));
					that.other.useToExtend = {}
				}
				return getGroups
			})
		},
		recieving: function() {
			var args = arguments[0];
			if (args instanceof Array || args instanceof String) {
				this.other.dynamicParameter = args
			} else {
				return false
			}
		},
		group: function() {
			var getModuleName, len = arguments[0],
				args = len(this, this.acceptCallInherit);
			if (isFun(len)) {
				getModuleName = args.reverse()
			}
			this.acceptCallInherit.initailizationStatus = getModuleName[0]
		},
		defineInvoking: function() {
			var customInvokingModel = this.acceptCallInherit.initailizationStatus.module;
			this.userModel[customInvokingModel] = this.next;
			for (prop in this.userModel) {
				if (this.userModel.hasOwnProperty(prop) && !this.hasOwnProperty(prop)) {
					this[prop] = this.userModel[customInvokingModel]
				}
			}
			return this
		},
		then: function(fn) {
			var that = this,
				output = null,
				shiftFirstParamater = null,
				options = this.thenCallInherit.chainStorage || options || undefined;
			shiftFirstParamater = this.observerDynamicData('dynamicParameter').shift();
			this.thenCallInherit.station.push(shiftFirstParamater);
			delete shiftFirstParamater;
			this.getArguments(fn).forEach(function(methods) {
				that.thenCallInherit.storage.push(methods)
			});
			var getModuleStringName = this.acceptCallInherit.initailizationStatus.module;
			if (getModuleStringName === '') {
				return this
			} else if (/^next$/i.test(getModuleStringName)) {
				return this
			} else {
				return this.defineInvoking()
			}
		},
		observerDynamicData: function(options) {
			if (options in this.other) {
				var param = this.other[options]
			}
			return param = param ? param : null
		},
		getArguments: function() {
			var args = arraySlice.call(arguments);
			return args
		},
		saveDelayRemoveData: function(options) {
			this.thenCallInherit.backUpremoveStorage.push(options)
		},
		all: function() {
			return false
		},
		getShift: function() {
			if (arguments.length > 0) {
				return arguments[0].shift()
			}
		},
		next: function() {
			var getStorageFunction = this.getShift(this.thenCallInherit.storage),
				getStorageFunctionArgument = arraySlice.call([getStorageFunction]),
				getchainStorageValue = this.getShift(this.thenCallInherit.chainStorage),
				getStationValue = this.getShift(this.thenCallInherit.station),
				results = null,
				that = this;
			this.saveDelayRemoveData(getStationValue);
			getStorageFunctionArgument.forEach(function(methods) {
				results = methods(getStationValue, getchainStorageValue, function() {
					that.thenCallInherit.chainStorageApi.push(arguments)
				})
			});
			if (results === undefined) {
				var chainStorageApiValue = this.thenCallInherit.chainStorageApi[0][0];
				this.thenCallInherit.chainStorage.push(chainStorageApiValue);
				this.thenCallInherit.chainStorageApi = [];
				return chainStorageApiValue
			} else {
				this.thenCallInherit.chainStorage.push(results);
				this.saveDelayRemoveData(results)
			}
			return results
		},
		debug: debug,
		hook: function(options) {
			var getHookName = new hookName();
			return getHookName.model(options)
		},
		trim: trim,
		extend: extend
	};

	function warn(options, log) {
		return function() {
			options.call(this, log)
		}
	};
	var debug = warn(function(options) {
		window.console.warn(options)
	}, 'disable write. call function err.');
	if (typeof module !== 'undefined' && module.exports && window.module !== module) {
		module.exports = REO
	} else if (typeof define === 'function' && define.amd) {
		define('REO', [], 'REO')
	} else {
		exports.Reo = REO
	}
})(typeof window !== 'undefined' ? this : global);